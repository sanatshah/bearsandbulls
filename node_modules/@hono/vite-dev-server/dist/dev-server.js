import { getRequestListener } from "@hono/node-server";
import { minimatch } from "minimatch";
import { getEnv as cloudflarePagesGetEnv } from "./cloudflare-pages/index.js";
const defaultOptions = {
  entry: "./src/index.ts",
  export: "default",
  injectClientScript: true,
  exclude: [
    /.*\.ts$/,
    /.*\.tsx$/,
    /^\/@.+$/,
    /^\/favicon\.ico$/,
    /^\/static\/.+/,
    /^\/node_modules\/.*/
  ],
  plugins: []
};
function devServer(options) {
  const entry = options?.entry ?? defaultOptions.entry;
  const plugin = {
    name: "@hono/vite-dev-server",
    configureServer: async (server) => {
      async function createMiddleware(server2) {
        return async function(req, res, next) {
          const exclude = options?.exclude ?? defaultOptions.exclude;
          for (const pattern of exclude) {
            if (req.url) {
              if (pattern instanceof RegExp) {
                if (pattern.test(req.url)) {
                  return next();
                }
              } else if (minimatch(req.url?.toString(), pattern)) {
                return next();
              }
            }
          }
          let appModule;
          try {
            appModule = await server2.ssrLoadModule(entry);
          } catch (e) {
            return next(e);
          }
          const exportName = options?.export ?? defaultOptions.export;
          const app = appModule[exportName];
          if (!app) {
            return next(new Error(`Failed to find a named export "${exportName}" from ${entry}`));
          }
          getRequestListener(
            async (request) => {
              let env = {};
              if (options?.env) {
                if (typeof options.env === "function") {
                  env = await options.env();
                } else {
                  env = options.env;
                }
              } else if (options?.cf) {
                env = await cloudflarePagesGetEnv(options.cf)();
              }
              if (options?.plugins) {
                for (const plugin2 of options.plugins) {
                  if (plugin2.env) {
                    env = typeof plugin2.env === "function" ? await plugin2.env() : plugin2.env;
                  }
                }
              }
              const response = await app.fetch(request, env, {
                waitUntil: async (fn) => fn,
                passThroughOnException: () => {
                  throw new Error("`passThroughOnException` is not supported");
                }
              });
              if (!(response instanceof Response)) {
                throw response;
              }
              if (options?.injectClientScript !== false && response.headers.get("content-type")?.match(/^text\/html/)) {
                const script = '<script>import("/@vite/client")</script>';
                return injectStringToResponse(response, script);
              }
              return response;
            },
            {
              errorHandler: (e) => {
                let err;
                if (e instanceof Error) {
                  err = e;
                  server2.ssrFixStacktrace(err);
                } else if (typeof e === "string") {
                  err = new Error(`The response is not an instance of "Response", but: ${e}`);
                } else {
                  err = new Error(`Unknown error: ${e}`);
                }
                next(err);
              }
            }
          )(req, res);
        };
      }
      server.middlewares.use(await createMiddleware(server));
      server.httpServer?.on("close", async () => {
        if (options?.plugins) {
          for (const plugin2 of options.plugins) {
            if (plugin2.onServerClose) {
              await plugin2.onServerClose();
            }
          }
        }
      });
    }
  };
  return plugin;
}
function injectStringToResponse(response, content) {
  const stream = response.body;
  const newContent = new TextEncoder().encode(content);
  if (!stream) {
    return null;
  }
  const reader = stream.getReader();
  const newContentReader = new ReadableStream({
    start(controller) {
      controller.enqueue(newContent);
      controller.close();
    }
  }).getReader();
  const combinedStream = new ReadableStream({
    async start(controller) {
      for (; ; ) {
        const [existingResult, newContentResult] = await Promise.all([
          reader.read(),
          newContentReader.read()
        ]);
        if (existingResult.done && newContentResult.done) {
          controller.close();
          break;
        }
        if (!existingResult.done) {
          controller.enqueue(existingResult.value);
        }
        if (!newContentResult.done) {
          controller.enqueue(newContentResult.value);
        }
      }
    }
  });
  const headers = new Headers(response.headers);
  headers.delete("content-length");
  return new Response(combinedStream, {
    headers,
    status: response.status
  });
}
export {
  defaultOptions,
  devServer
};
