import { jsx as _jsx, jsxs as _jsxs } from "frog/jsx/jsx-runtime";
import { detect } from 'detect-browser';
import { Hono } from 'hono';
import { ImageResponse } from 'hono-og';
import {} from 'hono/hono-base';
import {} from 'hono/types';
// TODO: maybe write our own "modern" universal path (or resolve) module.
// We are not using `node:path` to remain compatible with Edge runtimes.
import { default as p } from 'path-browserify';
import {} from './types.js';
import { fromQuery } from './utils/fromQuery.js';
import { getButtonValues } from './utils/getButtonValues.js';
import { getFrameContext } from './utils/getFrameContext.js';
import * as jws from './utils/jws.js';
import { parseBrowserLocation } from './utils/parseBrowserLocation.js';
import { parseIntents } from './utils/parseIntents.js';
import { parsePath } from './utils/parsePath.js';
import { requestToContext } from './utils/requestToContext.js';
import { serializeJson } from './utils/serializeJson.js';
import { toSearchParams } from './utils/toSearchParams.js';
import { version } from './version.js';
/**
 * A Frog instance.
 *
 * @param parameters - {@link FrogConstructorParameters}
 * @returns instance. {@link FrogBase}
 *
 * @example
 * ```
 * import { Frog } from 'frog'
 *
 * const app = new Frog()
 *
 * app.frame('/', (c) => {
 *   const { buttonValue, inputText, status } = c
 *   const fruit = inputText || buttonValue
 *   return c.res({
 *     image: (
 *       <div style={{ fontSize: 60 }}>
 *         {fruit ? `You selected: ${fruit}` : 'Welcome!'}
 *       </div>
 *     ),
 *     intents: [
 *       <Button value="apples">Apples</Button>,
 *       <Button value="oranges">Oranges</Button>,
 *       <Button value="bananas">Bananas</Button>,
 *     ]
 *   })
 * })
 * ```
 */
export class FrogBase {
    constructor({ assetsPath, basePath, browserLocation, dev, headers, honoOptions, hubApiUrl, imageOptions, initialState, secret, verify, } = {}) {
        // Note: not using native `private` fields to avoid tslib being injected
        // into bundled code.
        Object.defineProperty(this, "_imageOptions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_initialState", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: undefined
        });
        /** Path for assets. */
        Object.defineProperty(this, "assetsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** Base path of the server instance. */
        Object.defineProperty(this, "basePath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** URL to redirect to when the user is coming to the page via a browser. */
        Object.defineProperty(this, "browserLocation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "dev", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** Hono instance. */
        Object.defineProperty(this, "hono", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** Farcaster Hub API URL. */
        Object.defineProperty(this, "hubApiUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fetch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "get", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "post", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "use", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** Key used to sign secret data. */
        Object.defineProperty(this, "secret", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** Whether or not frames should be verified. */
        Object.defineProperty(this, "verify", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        this.hono = new Hono(honoOptions);
        if (basePath)
            this.hono = this.hono.basePath(basePath);
        if (browserLocation)
            this.browserLocation = browserLocation;
        if (headers)
            this.headers = headers;
        if (dev)
            this.dev = { enabled: true, ...(dev ?? {}) };
        if (hubApiUrl)
            this.hubApiUrl = hubApiUrl;
        if (imageOptions)
            this._imageOptions = imageOptions;
        if (secret)
            this.secret = secret;
        if (typeof verify !== 'undefined')
            this.verify = verify;
        this.basePath = basePath ?? '/';
        this.assetsPath = assetsPath ?? this.basePath;
        this.fetch = this.hono.fetch.bind(this.hono);
        this.get = this.hono.get.bind(this.hono);
        this.post = this.hono.post.bind(this.hono);
        this.use = this.hono.use.bind(this.hono);
        if (initialState)
            this._initialState = initialState;
    }
    frame(path, handler, options = {}) {
        const { verify = this.verify } = options;
        // Frame Route (implements GET & POST).
        this.hono.use(parsePath(path), async (c) => {
            const url = new URL(c.req.url);
            const assetsUrl = url.origin + parsePath(this.assetsPath);
            const baseUrl = url.origin + parsePath(this.basePath);
            const context = await getFrameContext({
                context: await requestToContext(c.req, {
                    hubApiUrl: this.hubApiUrl,
                    secret: this.secret,
                    verify,
                }),
                initialState: this._initialState,
                req: c.req,
            });
            if (context.status === 'redirect') {
                const location = context.buttonValue;
                if (!location)
                    throw new Error('location required to redirect');
                return c.redirect(location, 302);
            }
            if (context.url !== parsePath(c.req.url))
                return c.redirect(context.url);
            const { action, browserLocation = this.browserLocation, headers = this.headers, imageAspectRatio, image, intents, title = 'Frog Frame', } = await handler(context);
            const buttonValues = getButtonValues(parseIntents(intents));
            // If the user is coming from a browser, and a `browserLocation` is set,
            // then we will redirect the user to that location.
            const browser = detect(c.req.header('user-agent'));
            const browserLocation_ = parseBrowserLocation(c, browserLocation, path);
            if (browser?.name && browserLocation_)
                return c.redirect(browserLocation_.startsWith('http')
                    ? browserLocation_
                    : `${url.origin + p.resolve(this.basePath, browserLocation_)}`, 302);
            // The OG route also needs context, so we will need to pass the current derived context,
            // via a query parameter to the OG image route (/image).
            const baseContext = {
                ...context,
                // We can't serialize `request` (aka `c.req`), so we'll just set it to undefined.
                request: undefined,
            };
            const frameImageParams = toSearchParams(baseContext);
            // Derive the previous state, and sign it if a secret is provided.
            const previousState = await (async () => {
                const state = context.deriveState();
                if (!this.secret)
                    return state;
                if (!state)
                    return state;
                return jws.sign(JSON.stringify(state), this.secret);
            })();
            // We need to pass some context to the next frame to derive button values, state, etc.
            // Here, we are deriving two sets of "next frame state".
            // 1. For the INITIAL FRAME, we need to pass through the state as a search parameter
            //    due to Farcaster's constraints with the `fc:frame:state` tag. It must be empty
            //    for the initial frame.
            // 2. For SUBSEQUENT FRAMES, we can pass through the state as a serialized JSON object
            //    to the next frame via the `fc:frame:state` tag.
            const nextFrameStateSearch = toSearchParams({
                initialPath: context.initialPath,
                previousButtonValues: buttonValues,
            });
            const nextFrameStateMeta = serializeJson({
                initialPath: context.initialPath,
                previousButtonValues: buttonValues,
                previousState,
            });
            const imageUrl = (() => {
                if (typeof image !== 'string')
                    return `${parsePath(context.url)}/image?${frameImageParams.toString()}`;
                if (image.startsWith('http'))
                    return image;
                return `${assetsUrl + parsePath(image)}`;
            })();
            const postUrl = (() => {
                if (!action)
                    return context.url;
                if (action.startsWith('http'))
                    return action;
                return baseUrl + parsePath(action);
            })();
            const parsedIntents = parseIntents(intents, {
                baseUrl,
                search: context.status === 'initial'
                    ? nextFrameStateSearch.toString()
                    : undefined,
            });
            // Set response headers provided by consumer.
            for (const [key, value] of Object.entries(headers ?? {}))
                c.header(key, value);
            const isDevEnabled = 
            // check if devtools are enabled on constructor.
            (this.dev?.enabled ?? true) &&
                // check if route has `/dev` path.
                this.hono.routes.some((r) => {
                    if (!r.path.startsWith(this.basePath + parsePath(path)))
                        return false;
                    if (!r.path.includes('/dev'))
                        return false;
                    return true;
                });
            const body = isDevEnabled ? (_jsx("body", { style: {
                    alignItems: 'center',
                    display: 'flex',
                    justifyContent: 'center',
                    minHeight: '100vh',
                    overflow: 'hidden',
                }, children: _jsx("a", { style: { textDecoration: 'none' }, href: `${context.url}/dev`, children: "open \uD835\uDC87\uD835\uDC93\uD835\uDC82\uD835\uDC8E\uD835\uDC86 devtools" }) })) : (_jsx("body", {}));
            return c.render(_jsxs("html", { lang: "en", children: [_jsxs("head", { children: [_jsx("meta", { property: "fc:frame", content: "vNext" }), _jsx("meta", { property: "fc:frame:image:aspect_ratio", content: imageAspectRatio ?? '1.91:1' }), _jsx("meta", { property: "fc:frame:image", content: imageUrl }), _jsx("meta", { property: "og:image", content: imageUrl }), _jsx("meta", { property: "og:title", content: title }), _jsx("meta", { property: "fc:frame:post_url", content: context.status === 'initial'
                                    ? `${postUrl}?${nextFrameStateSearch.toString()}`
                                    : postUrl }), context.status !== 'initial' && (_jsx("meta", { property: "fc:frame:state", content: nextFrameStateMeta })), parsedIntents, isDevEnabled && (_jsx("meta", { property: "frog:context", content: serializeJson(baseContext) })), _jsx("meta", { property: "frog:version", content: version })] }), body] }));
        });
        // OG Image Route
        this.hono.get(`${parsePath(path)}/image`, async (c) => {
            const query = c.req.query();
            const context = await getFrameContext({
                context: fromQuery(query),
                initialState: this._initialState,
                req: c.req,
            });
            const { image, headers = this.headers, imageOptions = this._imageOptions, } = await handler(context);
            if (typeof image === 'string')
                return c.redirect(image, 302);
            return new ImageResponse(image, {
                ...imageOptions,
                headers: imageOptions?.headers ?? headers,
            });
        });
    }
    route(path, frog) {
        return this.hono.route(path, frog.hono);
    }
}
//# sourceMappingURL=frog-base.js.map