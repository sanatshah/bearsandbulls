import {} from '../types.js';
export function parseButtons(metaTags) {
    // https://regexr.com/7rlm0
    const buttonRegex = /fc:frame:button:(1|2|3|4)(?::(action|target))?$/;
    let currentButtonIndex = 0;
    let buttonsAreMissing = false;
    let buttonsAreOutOfOrder = false;
    const buttonMap = new Map();
    const buttonActionMap = new Map();
    const buttonTargetMap = new Map();
    const invalidButtons = [];
    for (const metaTag of metaTags) {
        const property = metaTag.getAttribute('property');
        if (!property)
            continue;
        if (!buttonRegex.test(property))
            continue;
        const matchArray = property.match(buttonRegex);
        const index = parseInt(matchArray[1], 10);
        const type = matchArray[2];
        const content = metaTag.getAttribute('content') ?? '';
        if (type === 'action')
            buttonActionMap.set(index, content);
        else if (type === 'target')
            buttonTargetMap.set(index, content);
        else {
            if (currentButtonIndex >= index)
                buttonsAreOutOfOrder = true;
            if (currentButtonIndex + 1 === index)
                currentButtonIndex = index;
            else
                buttonsAreMissing = true;
            if (buttonsAreOutOfOrder || buttonsAreMissing)
                invalidButtons.push(index);
            const title = content ?? index;
            buttonMap.set(index, { index, title });
        }
    }
    const buttons = [];
    for (const [index, button] of buttonMap) {
        const type = buttonActionMap.get(index) ?? 'post';
        const target = buttonTargetMap.get(index);
        buttons.push({
            ...button,
            ...(target ? { target } : {}),
            type,
        });
    }
    // Using `sort` over `toSorted` for Node.js < 20 compatibility (ie. Vercel default).
    buttons.sort((a, b) => a.index - b.index);
    return buttons;
}
//# sourceMappingURL=parseButtons.js.map